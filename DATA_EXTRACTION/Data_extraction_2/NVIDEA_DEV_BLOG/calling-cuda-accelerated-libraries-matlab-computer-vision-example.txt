In an earlier post we showed how MATLAB® can support CUDA kernel prototyping and development by providing an environment for quick evaluation and visualization using the CUDAKernel object. In this post I will show you how to integrate an existing library of both host and device code implemented in C++ or another CUDA-accelerated language using MEX. With MEX you can extend and customize MATLAB, or use MATLAB as a test environment for your production code.The MATLAB MEX compiler allows you to expose your libraries to the MATLAB environment as functions. You write your entry point in C, C++ or Fortran as a modified main() function which MATLAB invokes. MEX provides a framework for compiling this code, as well as an API for interacting with MATLAB and MATLAB data in your source code.MATLAB’s Parallel Computing Toolbox™ provides constructs for compiling CUDA C and C++ with nvcc, and new APIs for accessing and using the gpuArray datatype which represents data stored on the GPU as a numeric array in the MATLAB workspace.I am going to use a feature detection example from MATLAB’s documentation for Computer Vision System Toolbox™. This uses tracked features to remove camera shake from an in-car road video. You will need MATLAB®, Parallel Computing Toolbox™, Image Processing Toolbox™ and Computer Vision System Toolbox™ to run the code. You can request a trial of these products at www.mathworks.com/trial. This example also depends on the OpenCV Computer Vision library, compiled with CUDA support.Features are an essential prerequisite for many Computer Vision tasks; in this case, for instance, they might also be used to determine the motion of the car or to track other cars on the road.To set up the example environment, I am using the following MATLAB code to load the video and display the first two frames superimposed (Figure 1).Next I detect feature points in each image using one of the built-in feature detection routines provided with Computer Vision System Toolbox™. These points have properties, such as good contrast, that make them candidates for being detected in multiple images. Figure 2 shows the detected points.By looking at the neighborhood of pixels around each feature, I can extract feature “descriptors” that uniquely identify each point in a way invariant to the camera motion. I can then find matches between the features found in the two images. Computer Vision System Toolbox™ makes these steps easy to implement. Figure 3 shows the result.The next steps are to determine the motion of the camera and warp the images to provide a stabilized viewpoint.Detecting features is sometimes a computational bottleneck in the code and I may want to accelerate it on the GPU using a CUDA-accelerated library of computer vision routines, such as OpenCV. OpenCV provides the ORB algorithm with its CUDA support, an alternative feature detector to FAST. I’ll write a MEX function to implement that algorithm.I start by creating a new file for our CUDA C++ code. This needs to end in .cu in order for MEX to detect it as CUDA code.Here is the code for my MEX function. I will go through pointing out the key components, and then explain how to compile and run it.Your function must be called mexFunction and have the following signature.The parameters refer to the left-hand side and right-hand side arguments of the MATLAB statement that called this function. nlhs and nrhs are the number of left-hand and right-hand arguments, and plhs and prhs contain the data. mxArray is the base datatype that encapsulates all MATLAB variables. When I call my new MEX function from MATLAB as follows,I will have nlhs = 1, nrhs = 3, plhs[0] = points, prhs[0] = imgA, prhs[1] = numPoints, and prhs[2] = threshold.The first thing you should always do in a GPU MEX function is call mxInitGPU. This ensures that MATLAB loads its GPU libraries and selects a GPU. It should also throw an error (and cause your MEX function to return to MATLAB) if there is no compatible GPU available. I then check that the user has passed in the right arguments and throw appropriate error messages if they have not.I need to expose the input image as a mxGPUArray in order to access the device-side data. I do this using the API function mxGPUCreateFromMxArray which also copies the data across to the GPU if the input is not already a gpuArray.I should do some basic validation on the input image, making sure it is 2D 8-bit data. Of course I could write code to handle a variety of types, with a consequent increase in complexity. Note the API functions for getting the size and type of the data. They generally match the standard MEX C API, but with the prefix mxGPU instead of just mx.I retrieve the other inputs using mxGetScalar, which returns any data representable by a scalar double value as a double, or errors. Generally you should keep scalars and small arrays that represent sizes or settings on the CPU, since the data transfer time is not offset by any performance gains.I can now get hold of the GPU data as an address in device memory, to process it with the library’s tools.Running the detector is very specific to this problem, so I’ve set it aside in a local utility function iDetectFeatures. In it, I wrap my GPU data with OpenCV’s GpuMat datatype, initialise the ORB detector, set its parameters, and then run it on the wrapped data.I’ve decided to return the locations of the detected features as GPU data. This gives me the flexibility to keep the computation on the device for as long as possible in case I want to do further processing on the result. Actually accessing the data returned by OpenCV is again quite specific to this example, so I have put that functionality in another utility function, iCopyToMATLAB. Before I call it, I create the output gpuArray to hold the results.mxGPUCreateGPUArray is the function to create new gpuArrays, and the contents can either be left uninitialized (as here), or filled with zeros using MX_GPU_INITIALIZE_VALUES as the last argument. I then get another device pointer which iCopyToMATLAB uses for copying the results from OpenCV into the space just allocated.To return the result to MATLAB, I need to assign the output into the plhs array, but this requires converting back from a mxGPUArray to a mxArray using mxGPUCreateMxArrayOnGPU. The lingering mxGPUArrays are then destroyed – this only destroys header information, not the underlying device data.For CPU MEX functions compilation is usually little more than calling the function mex on your source code. For GPU MEX there are two extra things to do. Firstly, you need to copy the GPU mex options file from your MATLAB installation folder into the directory with your source. You can do this in MATLAB code as follows:Secondly, to make sure that MEX uses 64-bit types, you must also pass the option -largeArrayDims to mex.mex compiles and links your code into a shared library which MATLAB reads if you call a function of the same name (without the file extension). So for instance,will output a file (on Windows) called myMexFunction.mexw64 which you can run by typing myMexFunction into the command window.mex takes many of the same options as a typical command-line C compiler and linker. For this example, for instance, I need to link in the OpenCV libraries that provide the feature detector and accompanying utilities. I do this using the following command.For more details on the inputs to mex and other options such as compiling with debug symbols, see the documentation.With my mex function written and compiled I can now call detectORBFeatures in place of detectFASTFeatures in the above example.Figure 4 shows the points detected in the first image by the custom function. The ORB algorithm finds a different set of candidates for tracking than FAST, and I am hoping this will give me more matches between images and so more robust estimates of camera motion.To match these features without further customizations, I need to call gather on the points passed to extractFeatures, which doesn’t support gpuArray input. This will copy the data back to the CPU. The other functions handle gpuArray data with no changes.Using the ORB detector actually resulted in fewer matches than before (compare Figure 5 to Figure 3), although the video stabilization results may be equally good. In practice I would go on to determine whether making this change meets all my requirements for performance and accuracy.There are many reasons to implement your own custom MATLAB functions; one of them may be to improve performance over built-in MATLAB code. The best way to measure the performance of individual calls is to use the timeit and gputimeit functions. When I compare my new detector against the MATLAB built-in this way, I find that I’m not getting much benefit for these images.However, with larger images I see the benefit of a GPU-accelerated detector.Note that I have explicitly included transferring all the data to the GPU, and the results back to the CPU. If I were doing a series of operations on the GPU, such as some of the many GPU-accelerated image processing functions in Image Processing Toolbox™, there would be even more benefit.This MEX function needs further work to take it beyond a simple example. For robustness I would add more validation that the input is in an appropriate form. For flexibility, I may want to handle a variety of image formats, and allow more of the ORB detector parameters to be controlled from MATLAB. I may want to accept parameters as name-value pairs (as detectFASTFeatures does) rather than a fixed-order list.Once the input processing reaches a certain level of complexity, the best solution is to create a wrapper in MATLAB code. This opens up access to MATLAB’s input processing and validation tools such as narginchk, validateattributes and the input parser. It also makes it possible to specify help text for the function (in comments at the top of the file) that users can access by typing help detectORBFeatures.For most problems, MATLAB’s existing integration with CUDA already provides enough acceleration without the need for specialist knowledge of CUDA C/C++ or parallel algorithm development. In a future blog post we will show you more of what you can do without the need to leave the MATLAB language. MEX, as an advanced extension, gives the flexibility of integrating existing CUDA libraries and custom algorithms seamlessly with MATLAB.