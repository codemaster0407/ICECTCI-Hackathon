[
    {
        "question": "I am currently using the NVIDIA FleX package in Unity3D to create soft-bodied, jelly objects. I'm using Unity for animation only, not game dev. What I am aiming to make is a transparent, jello sphere that retains its spherical shape with elasticity. The first way I've tried to achieve this is using Flex Array + fluid setting. I've been playing with the settings but I can't get it to remain a sphere, it just becomes a more/less viscous fluid blob. The second way is using the Flex Soft + fluid setting. It is much better in terms of physics but even with \"draw particles\" off, but the water droplets are each separated and not one jelly sphere. This is what it looks like before hitting play, where the left is with Flex Array and the right is Flex Soft. The particles for Array are visible but not for Soft. This is after hitting play, where the Array becomes one viscous fluid, but not a sphere, and the Soft is very jello-like but the water droplets are all separated. A solution for either of the two ways would be much appreciated!",
        "answers": [
            [
                "the standard approach is to create an Nvidia Flex Controller first... Then you should also create a Flex Soft Asset... Then you should create or select a game object and through the Add Component tab in the game object's inspector, find the Flex Soft Actor component [see it loaded up in the image below]... Ensure your Soft Actor Asset mentioned previously has your required mesh type selected in the inspector option [I chose sphere in the image here] and check to see it looks something like the image below to be sure... So after that, hopefully, you can just press play and see it in action as it drops and contorts for you. If not, I have created a quick example for you to download as a unitypackage. It may still require further resolution with the package manager as the Flex plugin is already inside the package I'm providing here[Using Unity 2020.3.5f1] Flex in unity package Anyway, hope this gets you started and somewhere towards your goal with Flex. As a bonus, I've added a small script to move the flex object as this is outside of the usual approach as we have to call to the NVidia Flex component class of choice and invoke the ApplyImpulse method. Cheers :) Edit: There are a small 3 set of tutorials from NV Gameworks on integrating the plugin with Unity and exampling some stuff - this \"stuff\" is included in my downloadable package provided above. Here is the youtube link to the 3 set: Nvidia Gameworks FleX tutorials on Youtube Edit 2: rereading your question made me think I hadnt really given you the definitive answer as to using a cloth actor and having the mesh renderer deform via the flex cloth deform component. I am providing another link to another unity package here that will show this in action also allowing you to see the game object and how the cloth component from NVIDIA Flex works with the standard mesh filter and mesh renderer. Hope this more accurately answers your question :) Example also using Cloth Actors as well as Soft Actors in NVIDIA FleX"
            ]
        ],
        "votes": [
            1e-07
        ]
    },
    {
        "question": "I've read through the docs https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/flex/manual.html?ncid=afm-chs-44270&amp;ranMID=44270&amp;ranEAID=a1LgFw09t88&amp;ranSiteID=a1LgFw09t88-TGVNs5HtsNwQmL1xZ5XT8A#particles But I still can't get a working simulation. Are there any Debug options I dont't know about? I got Flex from https://github.com/NVIDIAGameWorks/FleX Here's my code: #pragma once #include \"FlexPhysics.h\" #include \"NvFlex.h\" #include \"NvFlexExt.h\" #include &lt;iostream&gt; NvFlexBuffer* particleBuffer; NvFlexBuffer* velocityBuffer; NvFlexBuffer* phaseBuffer; struct Vec4struct { float x, y, z, w; }; void MyErrorCallback(NvFlexErrorSeverity severity, const char* msg, const char* file, int line) { std::cout &lt;&lt; \"Flex: %s - %s:%d\\n\" &lt;&lt; msg &lt;&lt; file &lt;&lt; line &lt;&lt; std::endl; } int n = 10000; int main() { NvFlexLibrary* library = NvFlexInit(120, MyErrorCallback); // create new solver NvFlexSolverDesc solverDesc; NvFlexSetSolverDescDefaults(&amp;solverDesc); solverDesc.maxParticles = n; solverDesc.maxDiffuseParticles = 0; NvFlexSolver* solver = NvFlexCreateSolver(library, &amp;solverDesc); particleBuffer = NvFlexAllocBuffer(library, n, sizeof(Vec4struct), eNvFlexBufferHost); velocityBuffer = NvFlexAllocBuffer(library, n, sizeof(Vec4struct), eNvFlexBufferHost); phaseBuffer = NvFlexAllocBuffer(library, n, sizeof(int), eNvFlexBufferHost); //set params NvFlexParams p; p.gravity[0] = -10.0f; p.radius = 0.01f; p.drag = 0.1f; p.damping = 0.0f; NvFlexSetParams(solver, &amp;p); //spawn particles int particle_count = 6; float particle_mass = 100; //map buffers Vec4struct* particles = (Vec4struct*)NvFlexMap(particleBuffer, eNvFlexMapWait); Vec4struct* velocities = (Vec4struct*)NvFlexMap(velocityBuffer, eNvFlexMapWait); int* phases = (int*)NvFlexMap(phaseBuffer, eNvFlexMapWait); for (int i = 0; i &lt; particle_count; ++i) { particles[i] = { i * 5.0f,0,0, 1.0f / particle_mass }; velocities[i] = { 0.0f,0.0f,0.0f}; phases[i] = NvFlexMakePhase(0, 1); } //unmap buffers NvFlexUnmap(particleBuffer); NvFlexUnmap(velocityBuffer); NvFlexUnmap(phaseBuffer); NvFlexSetParticles(solver, particleBuffer, NULL); NvFlexSetVelocities(solver, velocityBuffer, NULL); NvFlexSetPhases(solver, phaseBuffer, NULL); float delta_time = 1 / 60.0f; while (true) { //map buffers Vec4struct* particles = (Vec4struct*)NvFlexMap(particleBuffer, eNvFlexMapWait); Vec4struct* velocities = (Vec4struct*)NvFlexMap(velocityBuffer, eNvFlexMapWait); int* phases = (int*)NvFlexMap(phaseBuffer, eNvFlexMapWait); //\"draw\" particles std::cout &lt;&lt; \"x:\" &lt;&lt; particles[0].x &lt;&lt; \" y:\" &lt;&lt; particles[0].y &lt;&lt; \" z:\" &lt;&lt; particles[0].z &lt;&lt; std::endl; //unmap buffers NvFlexUnmap(particleBuffer); NvFlexUnmap(velocityBuffer); NvFlexUnmap(phaseBuffer); // set active count NvFlexSetActiveCount(solver, particle_count); // tick NvFlexUpdateSolver(solver, delta_time, 1, false); // read back (async) NvFlexGetParticles(solver, particleBuffer, NULL); NvFlexGetVelocities(solver, velocityBuffer, NULL); NvFlexGetPhases(solver, phaseBuffer, NULL); } NvFlexFreeBuffer(particleBuffer); NvFlexFreeBuffer(velocityBuffer); NvFlexFreeBuffer(phaseBuffer); NvFlexDestroySolver(solver); NvFlexShutdown(library); return 0; } Here's some of the Output: x:0 y:0 z:0 x:0 y:0 z:0 x:0 y:0 z:0 x:0 y:0 z:0 x:0 y:0 z:0 x:0 y:0 z:0 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00274073 y:1.26542e+06 z:1.26542e+06 x:0.00550891 y:2.53083e+06 z:2.53083e+06 x:0.00550891 y:2.53083e+06 z:2.53083e+06 x:0.00550891 y:2.53083e+06 z:2.53083e+06 x:0.00550891 y:2.53083e+06 z:2.53083e+06 x:0.00550891 y:2.53083e+06 z:2.53083e+06 x:0.00550891 y:2.53083e+06 z:2.53083e+06 x:0.00550891 y:2.53083e+06 z:2.53083e+06 x:0.00550891 y:2.53083e+06 z:2.53083e+06 x:0.00550891 y:2.53083e+06 z:2.53083e+06 Now I'd expect the particles to start Falling to the right. Im not sure the data I load into the particlebuffer is correct how can I check that? All the docs say is [float x, float y, float z, inverse_mass]. What Parameters should I check? And all I can find to the buffer is: /** * Opaque type representing a data buffer, type and contents depends on usage, see NvFlexAllocBuffer() */ typedef struct NvFlexBuffer NvFlexBuffer;",
        "answers": [
            [
                "You Have to Initialize all the Flex Params or else it simple wont work, i think this is because they're saved in a struct. #pragma once #include \"FlexPhysics.h\" #include \"NvFlex.h\" #include \"NvFlexExt.h\" #include &lt;iostream&gt; NvFlexBuffer* particleBuffer; NvFlexBuffer* velocityBuffer; NvFlexBuffer* phaseBuffer; struct Vec4struct { float x, y, z, w; }; void MyErrorCallback(NvFlexErrorSeverity severity, const char* msg, const char* file, int line) { std::cout &lt;&lt; \"Flex: %s - %s:%d\\n\" &lt;&lt; msg &lt;&lt; file &lt;&lt; line &lt;&lt; std::endl; } int n = 10000; int main() { NvFlexLibrary* library = NvFlexInit(120, MyErrorCallback); // create new solver NvFlexSolverDesc solverDesc; NvFlexSetSolverDescDefaults(&amp;solverDesc); solverDesc.maxParticles = n; solverDesc.maxDiffuseParticles = 0; NvFlexSolver* solver = NvFlexCreateSolver(library, &amp;solverDesc); particleBuffer = NvFlexAllocBuffer(library, n, sizeof(Vec4struct), eNvFlexBufferHost); velocityBuffer = NvFlexAllocBuffer(library, n, sizeof(Vec4struct), eNvFlexBufferHost); phaseBuffer = NvFlexAllocBuffer(library, n, sizeof(int), eNvFlexBufferHost); //set params NvFlexParams p; int numIterations = 2; //!&lt; Number of solver iterations to perform per-substep p.gravity[0] = 0; p.gravity[1] = -10.0f; p.gravity[2] = 0; //!&lt; Constant acceleration applied to all particles p.radius = 0.01; //!&lt; The maximum interaction radius for particles p.solidRestDistance = 0.005; //!&lt; The distance non-fluid particles attempt to maintain from each other, must be in the range (0, radius] p.fluidRestDistance = 0.001; //!&lt; The distance fluid particles are spaced at the rest density, must be in the range (0, radius], for fluids this should generally be 50-70% of mRadius, for rigids this can simply be the same as the particle radius // common params p.dynamicFriction = 1; //!&lt; Coefficient of friction used when colliding against shapes p.staticFriction = 1; //!&lt; Coefficient of static friction used when colliding against shapes p.particleFriction = 1; //!&lt; Coefficient of friction used when colliding particles p.restitution = 1; //!&lt; Coefficient of restitution used when colliding against shapes, particle collisions are always inelastic p.adhesion = 1; //!&lt; Controls how strongly particles stick to surfaces they hit, default 0.0, range [0.0, +inf] p.sleepThreshold = 1; //!&lt; Particles with a velocity magnitude &lt; this threshold will be considered fixed p.maxSpeed = 1000; //!&lt; The magnitude of particle velocity will be clamped to this value at the end of each step p.maxAcceleration = 1000; //!&lt; The magnitude of particle acceleration will be clamped to this value at the end of each step (limits max velocity change per-second), useful to avoid popping due to large interpenetrations p.shockPropagation = 0; //!&lt; Artificially decrease the mass of particles based on height from a fixed reference point, this makes stacks and piles converge faster p.dissipation = 1; //!&lt; Damps particle velocity based on how many particle contacts it has p.damping = 10; //!&lt; Viscous drag force, applies a force proportional, and opposite to the particle velocity // cloth params p.wind[0] = 0; p.wind[0] = 0; p.wind[0] = 0; //!&lt; Constant acceleration applied to particles that belong to dynamic triangles, drag needs to be &gt; 0 for wind to affect triangles p.drag = 1; //!&lt; Drag force applied to particles belonging to dynamic triangles, proportional to velocity^2*area in the negative velocity direction p.lift = 1; //!&lt; Lift force applied to particles belonging to dynamic triangles, proportional to velocity^2*area in the direction perpendicular to velocity and (if possible), parallel to the plane normal // fluid params p.cohesion = 0.025; //!&lt; Control how strongly particles hold each other together, default: 0.025, range [0.0, +inf] p.surfaceTension = 0; //!&lt; Controls how strongly particles attempt to minimize surface area, default: 0.0, range: [0.0, +inf] p.viscosity = 1; //!&lt; Smoothes particle velocities using XSPH viscosity p.vorticityConfinement = 0; //!&lt; Increases vorticity by applying rotational forces to particles p.anisotropyScale = 0; //!&lt; Control how much anisotropy is present in resulting ellipsoids for rendering, if zero then anisotropy will not be calculated, see NvFlexGetAnisotropy() p.anisotropyMin = 0; //!&lt; Clamp the anisotropy scale to this fraction of the radius p.anisotropyMax = 0; //!&lt; Clamp the anisotropy scale to this fraction of the radius p.smoothing = 1; //!&lt; Control the strength of Laplacian smoothing in particles for rendering, if zero then smoothed positions will not be calculated, see NvFlexGetSmoothParticles() p.solidPressure = 0; //!&lt; Add pressure from solid surfaces to particles p.freeSurfaceDrag = 0; //!&lt; Drag force applied to boundary fluid particles p.buoyancy = 0; //!&lt; Gravity is scaled by this value for fluid particles // diffuse params p.diffuseThreshold = 0; //!&lt; Particles with kinetic energy + divergence above this threshold will spawn new diffuse particles p.diffuseBuoyancy = 0; //!&lt; Scales force opposing gravity that diffuse particles receive p.diffuseDrag = 0; //!&lt; Scales force diffuse particles receive in direction of neighbor fluid particles p.diffuseBallistic = 0; //!&lt; The number of neighbors below which a diffuse particle is considered ballistic p.diffuseLifetime = 0; //!&lt; Time in seconds that a diffuse particle will live for after being spawned, particles will be spawned with a random lifetime in the range [0, diffuseLifetime] // collision params p.collisionDistance = 0.01; //!&lt; Distance particles maintain against shapes, note that for robust collision against triangle meshes this distance should be greater than zero p.particleCollisionMargin = 1; //!&lt; Increases the radius used during neighbor finding, this is useful if particles are expected to move significantly during a single step to ensure contacts aren't missed on subsequent iterations p.shapeCollisionMargin = 0; //!&lt; Increases the radius used during contact finding against kinematic shapes for (int i = 0; i &lt; 8; i++) { for (int j = 0; j &lt; 4; j++) { p.planes[i][j] = 0; } } //!&lt; Collision planes in the form ax + by + cz + d = 0 p.numPlanes = 0; //!&lt; Num collision planes p.relaxationMode = NvFlexRelaxationMode::eNvFlexRelaxationGlobal; //!&lt; How the relaxation is applied inside the solver p.relaxationFactor = 1; //!&lt; Control the convergence rate of the parallel solver, default: 1, values greater than 1 may lead to instability NvFlexSetParams(solver, &amp;p); //spawn particles int particle_count = 6; float particle_mass = 100; //map buffers Vec4struct* particles = (Vec4struct*)NvFlexMap(particleBuffer, eNvFlexMapWait); Vec4struct* velocities = (Vec4struct*)NvFlexMap(velocityBuffer, eNvFlexMapWait); int* phases = (int*)NvFlexMap(phaseBuffer, eNvFlexMapWait); for (int i = 0; i &lt; particle_count; ++i) { particles[i] = { i * 5.0f,0,0, 1.0f / particle_mass }; velocities[i] = { 0.0f,0.0f,0.0f }; phases[i] = NvFlexMakePhase(0, 1); } //unmap buffers NvFlexUnmap(particleBuffer); NvFlexUnmap(velocityBuffer); NvFlexUnmap(phaseBuffer); NvFlexSetParticles(solver, particleBuffer, NULL); NvFlexSetVelocities(solver, velocityBuffer, NULL); NvFlexSetPhases(solver, phaseBuffer, NULL); float delta_time = 1 / 60.0f; while (true) { //map buffers Vec4struct* particles = (Vec4struct*)NvFlexMap(particleBuffer, eNvFlexMapWait); Vec4struct* velocities = (Vec4struct*)NvFlexMap(velocityBuffer, eNvFlexMapWait); int* phases = (int*)NvFlexMap(phaseBuffer, eNvFlexMapWait); //\"draw\" particles std::cout &lt;&lt; \"x:\" &lt;&lt; particles[0].x &lt;&lt; \" y:\" &lt;&lt; particles[0].y &lt;&lt; \" z:\" &lt;&lt; particles[0].z &lt;&lt; std::endl; //unmap buffers NvFlexUnmap(particleBuffer); NvFlexUnmap(velocityBuffer); NvFlexUnmap(phaseBuffer); // set active count NvFlexSetActiveCount(solver, particle_count); // tick NvFlexUpdateSolver(solver, delta_time, 1, false); // read back (async) NvFlexGetParticles(solver, particleBuffer, NULL); NvFlexGetVelocities(solver, velocityBuffer, NULL); NvFlexGetPhases(solver, phaseBuffer, NULL); } NvFlexFreeBuffer(particleBuffer); NvFlexFreeBuffer(velocityBuffer); NvFlexFreeBuffer(phaseBuffer); NvFlexDestroySolver(solver); NvFlexShutdown(library); return 0; }"
            ]
        ],
        "votes": [
            1e-07
        ]
    },
    {
        "question": "I'm working on a compute shader that allows two-way physics interaction between a fluid particle engine (NVidia Flex) and a rigidbody physics engine (Unity3D Engine). Basically for the compute shader I'm using 5 input buffers: (float4) particle velocities / shape contact indices (float4) shape centroids (int) shape flags - dynamic vs static etc (int) particle indices (float4) particle positions and mass and 2 output buffers: (float3) velocity delta (float3) rotational velocity delta The functionality that I'm looking for is minimal and does not need to be accurate, it just needs to be somewhat believable, as I'm mostly just using this for visual effects. I know I can create rigidbody constraints with NVidia flex particles and use that, but in my case this would not be practical because my fluid simulation uses very small particles and medium-sized rigiddodies would use many more particles with the NVidia rigid constraints than the documentation says is recommended per body. So anyway, I've gotten to the point where in my shader all I need is a physics formula to take in the origin point of a force in world space, the force vector, the shape's center of mass in world space, and I need it to give me both the net delta velocity of the shape (assuming uniform density), and the net rotational velocity of the shape. This function will be applied on each shape many times for each contact between itself and a particle. Here is some psuedo code: // The velocity of the particle at the time of contact float4 contactVelocity; // The index of the shape that the particle collided with int shapeIndex; // The particle's position in the world (which should be the same as the contact point) float3 pos; // The mass of the particle float mass; // The shape's center of mass float3 shapeOrigin; // TODO: define ApplyVelForce &amp; ApplyRotForce velDelta[shapeIndex] = velDelta[shapeIndex] + GetVelForce(shapeOrigin, contactVelocity * mass, pos); rotVelDelta[shapeIndex] = rotVelDelta[shapeIndex] + GetRotForce(shapeOrigin, contactVelocity * mass, pos); // function definitions float3 GetVelForce(float3 shapeCentroid, float3 force, float3 forcePoint){ /* TODO define */ } float3 GetRotForce(float3 shapeCentroid, float3 force, float3 forcePoint){ /* TODO define */ } If anyone knows a relatively simple formula to calculate or even approximate these velocity and rotation forces reasonably efficiently, please let me know. I've scoured google but all the articles about this seem to be way over my head. I just don't think I've got enough experience and knowledge about kinematics yet to figure out formulas like these on my own.",
        "answers": [
            [
                "What you want is in general underdetermined, given the information you want as input. In the general case, you need as input: Input: center of mass of shape : x_c (changes with time) orientation of shape in space : U (orthogonal matrix, equivalent to a coordinate frame attached to and moving with the shape, changes with time) Force vector in world space : f (changes with time) point of force in world space : x_F (changes with time) inertia matrix of the shape : J (constant) mass of shape : m (constant) Output: Velocity of center of mass : v_c (changes with time) Angular velocity of shape in world frame : o (changes with time) In general, the full description of a rigid body's position and orientation in world frame at any given moment of time is given by: x_c = x_c(t), U = U(t) where U is 3 by 3 orthogonal matrix, whose columns are the coordinates of 3 unit vectors of a coordinate frame firmly attached to and moving with the rigid body with origin at the point x_c. Assume that some force is applied to a point X_F on the rigid body, where the coordinates of X_F are in the frame attached to the rigid body (not in the world system). In reasonable models we assume that he point X_F doesn't change with time in the body-fixed frame (of course it changes in the world frame). Let the vector of the force, in the frame attached to the body, be F and the angular velocity expressed in the body-fixed frame be O. Then, in world frame: point of force: x_F = x_c + U * X_F force: f = U*F angular velocity (along the momentary axis of rotation): o = U*O The equations of motion then are d/dt(x_c) = v_c d/dt(v_c) = U*F / m d/dt (J*O) = cross(J*O, O) + U.T * cross(X_F, F) d/dt U = U*matrix(O) where x_c = center of mass, v_c = velocity of center of mass, O = angular velocity in body fixed frame, U = 3 by 3 orthogonal a matrix with columns the orientations of the axis of the body fixed system F = force in body-fixed frame X_F = point of force in body fixed frame So, a simple iterative scheme that produces the motion of a rigid body is input: x_c_in, v_c_in, U_in, O_in, J, m, X_F, F, h = time-step x_c_out = x_c_in + h*v_c_in v_c_out = v_c_in + h*(U_in * F_in)/m Rot_hO = rotate(h*O_in) (perform rotation around axis determined by vector O and angle h*norm(O)) U_out = U_in * Rot_hO O_out = O_in + h*inverse(J)*( cross(J*O_in, O_in) + cross(X_F, F) ) output: x_c_out, v_c_out, U_out, O_out, Somewhere there should be a function that calculates the force F in the body-fixed frame. It could be that F is simply a constant vector, it could be changing its magnitude and direction only with respect to time F = F(t), or it could in general depend on the body position, orientation, velocity and even angular velocity, so F = F(x_c, v_c, U, O)."
            ]
        ],
        "votes": [
            1e-07
        ]
    },
    {
        "question": "This might be a rather niche question, but maybe someone can help me out. I used the NVIDIA Flex plugin for unity to create a soft body object in a sphere shape and I would like to move it around by applying an impulse to it. Without Flex, I would just use a rigidbody and the addforce function. But because Flex uses it's own Physic calculation and sets the position of the object accordingly, at least that's what it looks like to me, the addForce is just completely ignored... So how would I add the force to the Flex-Object?",
        "answers": [
            [
                "you need to get reference to FlexActor component, and then add impulse using System.Collections; using System.Collections.Generic; using UnityEngine; using NVIDIA; void Start() { FlexComponet = GetComponent&lt;NVIDIA.Flex.FlexSolidActor&gt;(); } public float mul = 100f; void Update() { input = new Vector3(Input.GetAxis(\"Horizontal\"),0,Input.GetAxis(\"Vertical\")); FlexComponet.ApplyImpulse(input*mul); }"
            ]
        ],
        "votes": [
            4.0000001
        ]
    },
    {
        "question": "When creating a soft body in Nvidia Flex using NvFlexExtCreateSoftFromMesh() which results in particles grouped together in clusters, which constraint type of Position-Based Dynamics will be used? Is it shape matching or general distance constraints or something else? I appreciate any help.",
        "answers": [
            [
                "According to this manual: https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/flex/manual.html, each cluster is held together with shape matching constraints. The soft body as a whole is held together by the fact that each particle can be a member of multiple clusters. NvFlexExtCreateSoftFromMesh() also receives a float parameter called linkRadius. If you provide a linkRadius larger than particleSpacing, the function will additionally create springs (regular distance constraints) between the particles in the soft body."
            ]
        ],
        "votes": [
            1.0000001
        ]
    },
    {
        "question": "Im new to coding in C# and I'm not able to set the particle count in the Nvidia FlexArray script, the particle count public class appears grey and can't be edited. It is somehow permanently set to 0. Ive attached an image and the script that comes with the package. Id greatly appreciate any help. The image for the inspector view on array actor using UnityEngine; namespace NVIDIA.Flex { [ExecuteInEditMode] public class FlexArrayAsset : FlexAsset { #region Properties public Mesh boundaryMesh { get { return m_boundaryMesh; } set { m_boundaryMesh = value; } } public Vector3 meshLocalScale { get { return m_meshLocalScale; } set { m_meshLocalScale = value; } } public float meshExpansion { get { return m_meshExpansion; } set { m_meshExpansion = value; } } public float particleSpacing { get { return m_particleSpacing; } set { m_particleSpacing = Mathf.Max(value, 0.01f); } } public float particleCount { get { return m_particleCount; } set { m_particleCount = Mathf.Max(value, 516f); } } #endregion #region Methods #endregion #region Messages #endregion #region Protected protected override void ValidateFields() { base.ValidateFields(); m_particleSpacing = Mathf.Max(m_particleSpacing, 0.01f); } protected override void RebuildAsset() { BuildFromMesh(); base.RebuildAsset(); } #endregion #region Private void BuildFromMesh() { if (m_boundaryMesh) { Vector3[] vertices = m_boundaryMesh.vertices; if (vertices != null &amp;&amp; vertices.Length &gt; 0) { for (int i = 0; i &lt; vertices.Length; ++i) { Vector3 v = vertices[i]; vertices[i] = new Vector3(v.x * m_meshLocalScale.x, v.y * m_meshLocalScale.y, v.z * m_meshLocalScale.z); } int[] indices = m_boundaryMesh.triangles; if (indices != null &amp;&amp; indices.Length &gt; 0) { FlexExt.Asset.Handle assetHandle = FlexExt.CreateRigidFromMesh(ref vertices[0], vertices.Length, ref indices[0], indices.Length, m_particleSpacing, m_meshExpansion); if (assetHandle) { FlexExt.Asset asset = assetHandle.asset; FlexExt.Asset particlesOnly = new FlexExt.Asset(); particlesOnly.numParticles = asset.numParticles; particlesOnly.maxParticles = asset.numParticles; particlesOnly.particles = asset.particles; StoreAsset(particlesOnly); FlexExt.DestroyAsset(assetHandle); } } } } } [SerializeField] Mesh m_boundaryMesh = null; [SerializeField] Vector3 m_meshLocalScale = Vector3.one; [SerializeField, Tooltip(\"Particles will be moved inwards (if negative) or outwards (if positive) from the surface of the mesh according to this factor\")] float m_meshExpansion = 0.0f; [SerializeField, Tooltip(\"The spacing used for voxelization, note that the number of voxels grows proportional to the inverse cube of radius, currently this method limits construction to resolutions &lt; 64^3\")] float m_particleSpacing = 0.1f; #endregion } }",
        "answers": [
            [
                "Properties can't be serialized directly in Unity. Recommended flow would be to mark m_particleCount as a [SerializeField], which exposes it to the editor even if it's private. It looks like it might be buried in the Flex API though, so I'm not sure if you can edit it directly. A more complex editor script could do the job in such a case, I'd recommend looking at trying to hack the value with your own value, then using OnValidate() to write that value to the real one. That said, is this value really what you think it is? I haven't used the API but 'particleCount' is usually the number of live particles in the system, naturally at edit time it would be 0, but at runtime it could be 10 or 20 or 1000 depending on what the particle system is doing."
            ]
        ],
        "votes": [
            1e-07
        ]
    },
    {
        "question": "I am exporing Nvidia's Flex but I am very new to D3D. I am trying to copy between two ID3D11Buffer which are created using different D3D11_BUFFER_DESC. I wanted to use ID3D11DeviceContext::CopyResource() since it's GPU-GPU copy but the code is throwing exception. Two buffers are created as below: //First Buffer: D3D11_BUFFER_DESC bufDesc; bufDesc.ByteWidth = numParticles*sizeof(Vec4); bufDesc.Usage = D3D11_USAGE_DYNAMIC; bufDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER; bufDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; bufDesc.MiscFlags = 0; bufDesc.StructureByteStride = 0; m_device-&gt;CreateBuffer(&amp;bufDesc, NULL, buff0); //Second Buffer D3D11_BUFFER_DESC bufDescTemp; bufDescTemp.ByteWidth = numParticles * sizeof(Vec4); bufDescTemp.Usage = D3D11_USAGE_DEFAULT; bufDescTemp.BindFlags = D3D11_BIND_VERTEX_BUFFER; bufDescTemp.CPUAccessFlags = D3D11_CPU_ACCESS_READ;//D3D11_CPU_ACCESS_READ;// bufDescTemp.MiscFlags = 0; bufDescTemp.StructureByteStride = 0; m_device-&gt;CreateBuffer(&amp;bufDescTemp, NULL, buff1); Then at each frame I get an updated buff0 from Flex's NvFlexGet. Then I try to copy buff0 to buff1: context-&gt;CopyResource(buff1,buff0); But this line throws exception. It works fine if both buffers are created using D3D11_USAGE_DYNAMIC. But not when buff1 is D3D11_USAGE_DEFAULT. Does ID3D11DeviceContext::CopyResource supports copy between buffers with different D3D11_USAGE? Or did I miss something?",
        "answers": [
            [
                "D3D11_USAGE_DYNAMIC means a resource that is accessible by both the GPU (read only) and the CPU (write only). That's why it cannot be used in CopyResource."
            ]
        ],
        "votes": [
            1e-07
        ]
    },
    {
        "question": "I'm trying to compile Flex on Linux (Ubuntu 14.04). I'm getting the following error that I haven't been able to wrap my head around: /usr/bin/ld: ../../../external/SDL2-2.0.4/lib/x64//libSDL2.a(SDL_syssem.o): undefined reference to symbol 'sem_getvalue@@GLIBC_2.2.5' //lib/x86_64-linux-gnu/libpthread.so.0: error adding symbols: DSO missing from command line collect2: error: ld returned 1 exit status I have CUDA 7.5 installed with one of the latest NVIDIA drivers. Would appreciate your comments on how I should solve the issue.",
        "answers": [
            [
                "I simply downloaded Flex v1.2 and it complied with no issues."
            ]
        ],
        "votes": [
            1e-07
        ]
    },
    {
        "question": "does anyone know how to make a cable component respond to being blocked by other physics components in unreal engine 4? game has a swinging rope that should wrap around objects it hits, instead every setting I try it is still passing through them.",
        "answers": [
            [
                "I think the cable component isn't fully fleshed out, in that it doesn't do any kind of collision work. If you want cables that can wrap, look at NVidia FleX (they have a github with a working implementation in 4.15)"
            ]
        ],
        "votes": [
            1e-07
        ]
    },
    {
        "question": "So I'm trying to use the flex API by NVIDIA for my game engine(as a core gameplay mechanic) and I'm now arranging my data structures. I've already read the flex Manual, but the descriptions are rather sparsely. Because I'm also using CUDA, I need to know if the flex API calls like flexSetParticles etc. also accept device pointers as inputs. Also, it would be nice if someone could tell me, what exactly flexUpdateSolver does. Does it compute the velocities itself? Does it calculate gravity? If no, and you have to calculate the updated velocities yourself, what does the Solver even do? At the moment, I calculate the new positions and velocities myself(without flex) like this: void updateParticle(int i, float deltaTime) { velocities[i] = types[i].getVelocity(deltaTime); //calculates the currently fixed velocity at a given time positions[i] = positions[i] + velocities[i]; } All the arrays in the function above are device pointers and the function is actually a kernel. If I now have to calculate the velocities myself, I would have to 1.) update the arrays by adding new particles if necessary(from host to device) and calculate velocities(device) 2.) copy the new positions (and velocities) back to the CPU and hand them over to flex 3.) after flex has finished, copy the new positions from flexGetParticles back to the GPU (an OpenGL buffer for rendering) This seems pretty inefficient, so I would like to know if there is an easier solution.",
        "answers": [
            [
                "Yes, the flexUpdateSolver will calculate the positions and velocities for the particles internally. So, you must not do that yourself. Remember that, you have to call NvFlexGetParticles(particleBuffer, n) to get the updated positions and velocities after each time step. As for the flexSetParticles, it takes either a Host or Device buffer pointer. You can create the buffer using NvFlexAllocBuffer by passing the appropriate NvFlexBufferType enum."
            ]
        ],
        "votes": [
            2.0000001
        ]
    }
]