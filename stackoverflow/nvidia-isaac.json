[
    {
        "question": "I have tried to install Isaac Gym on Ubunt 18.04 with nvidia 1060 and the 470 driver. Everything is ok after I \"sudo apt install libpython3.7\" following the official index.html. However I got error showing:\" failed to load '../..assests/urdf/ball/urdf'\" with the ending of \"segmentation fault\" I checked the directory and found the corresponding urdf file, it is confusing why the Isaac Gym gets such an error I have searched over the Google but gotten nothing like my situation.",
        "answers": [],
        "votes": []
    },
    {
        "question": "I am using python API to write USDA scripts, a human-readable USD (Universal Scene Description) file format. The task is to render a polygon with holes in it. The closest attribute in the openUSD repository is holeIndices, as shown here: https://openusd.org/dev/api/class_usd_geom_mesh.html#a70e20683a4bdc2e3925cb2a4e9759702. The definition for the attribute is \"The indices of all faces that should be treated as holes, i.e. made invisible.\" The problem is that, it only made the referred polygon composed of inner vertices invisible but doesn't hide or \"cut out\" the display of the large polygon composed of outer vertices. Therefore, it makes no contribution to visually \"forming a hole\" on the existing polygon. I can prove it with the example I provided below. def Xform \"Plane\" { def Mesh \"Mesh\" { int[] faceVertexCounts = [4, 4] int[] faceVertexIndices = [0, 1, 2, 3, 5, 6, 7, 4] int[] holeIndices = [1, 0] point3f[] points = [(-1, -1, 0), (-1, 1, 0), (1, 1, 0), (1, -1, 0), (-0.5, -0.5, 0), (0.5, -0.5, 0), (0.5, 0.5, 0), (-0.5, 0.5, 0), (-0.8, -1, 0), (-0.4, -0.5, 0)] } } My question is, to achieve such a simple effect of displaying a hollowed polygon in USD, why isn't there a useful function or attribute to subtract the existing polygon to achieve it except this useless holeIndices attribute? If there really isn't a built-in function in openUSD to easily achieve that, another option is to triangulate the polygon into many small convex polygons before feeding into the USD file, which would take lots of unnecessary computation. This procedure seems silly and redundant if just for displaying polygons with holes. Any advice for displaying hollowed polygons in USD or about this unfathomable openUSD's design of holeIndices?",
        "answers": [],
        "votes": []
    },
    {
        "question": "I am working with the Boston Dynamics quadruped robot, Spot, on NVIDIA Isaac Sim with NVIDIA Orbit. I am trying to replicate the motion of the Unitree A1/Go, which is already present in Isaac Sim's examples along with using a URDF and mesh files of Spot. I am not able to find the location of the files given in the simulator such as /GroundPlane_01, /OmniverseKit_Persp or even those that refer to the robot I have imported to the sim such as /spot/base/visuals, /spot/fl_uleg/visuals, etc. I am using Ubuntu 20.04. If anyone can help, may I please know what the location of / is in NVIDIA Omniverse? Thank you.",
        "answers": [],
        "votes": []
    },
    {
        "question": "I'm trying to start working with Nvidia's Isaac Gym software in a new Conda environment and am running into some issues. Firstly, the software requires a Conda environment of Python 3.8. Secondly, the software requires Pytorch be installed and functional with my GPU. I have a 3080 Ti, which means Pytorch needs to be installed with CUDA 11.3 (or, at least, newer than 10.2). As Isaac Gym's setup installs it with CUDA 10.2, I need to install Pytorch elsewhere. Whenever I run the CUDA 11.3 Pytorch install in the Conda environment as described by the menu on https://pytorch.org/, it bumps the Python version in the Conda environment. My workflow is described below: 1. Create the Conda environment: conda create --name isaacEnv python=3.8 2. Activate the Conda environment: conda activate isaacEnv 3. Check Python version, which returns Python 3.8.13 python --version This returns Python 3.8.13 4. Install the rest of the Nvidia Isaac Gym stuff. This step doesn't impact any later steps but is detailed in their installation documentation (downloadable from their website). It does not end up mattering because the script they use installs torch with Cuda 10.2, which--as stated--is incompatible with my 3080 Ti. This step is also likely independent of the problem, as the next step causes issues regardless: 5. Install Pytorch with CUDA 11.3 As detailed on pytorch.org: conda install pytorch torchvision torchaudio cudatoolkit=11.3 -c pytorch At this stage, even if I hit \"no\" to cancel the installation, when I run python --version again, it will show Python 3.9.12, which is the default version on this PC. tl;dr: Is there a way to install Pytorch with CUDA 11.3 without upgrading from Python 3.8 in the Conda environment in the process?",
        "answers": [
            [
                "I have faced the same question today. It seems like you just need to open another terminal, and the python version will revert to normal... Maybe it's something about CUDA. Update: I have considered this question again. Now I tend to that this is a bug with conda updating. After I created the new env, I run an updating just as what conda advised me to do. And since then the python attaching to my terminal was always the one in base env."
            ]
        ],
        "votes": [
            1e-07
        ]
    },
    {
        "question": "I'm trying to run a program called Isaac-Sim from inside of an outer docker container (called container A for reference), but Isaac-Sim already runs in its own docker container. The end goal is to modify this to use Isaac output, but for now I just need to make a basic container that can run Isaac inside of it to get started. In addition to needing access to the specific image, it also has a lot of volumes that mount files from the main OS it needs to properly work. I'm pretty unfamiliar with docker and have tried looking stuff up, but am just not quite sure where to start. From my understanding so far, I would need to mount the volumes Isaac needs inside of container A and define the volumes for the Isaac container relative to the container A file path rather than the main OS. I would also need to make a volume in container A -v /var/run/docker.sock:/var/run/docker.sock. This should allow me to run a docker run command inside of container A and have it start a parrallel container. However, what I'm not sure of is how to get access to the actual image for the Isaac container inside of container A. It's a rather lengthy installation process, so I don't want to reinstall it on container A every time I run it, I'd rather just volumize where it already is...but I'm not quite sure where that is.",
        "answers": [],
        "votes": []
    },
    {
        "question": "Hello I want to use isaacgym environment to train my own agent to complete this, I modify cartpole_task.py to multiple environment. so I change num_envs=2 in __init__ method like below code class CartpoleTask(BaseTask): def __init__( self, name, headless, offset=None, ) -&gt; None: self.headless = headless # task-specific parameters self._cartpole_position = [0.0, 0.0, 2.0] self._cartpole_position2 = [2.0, 0.0, 2.0] self._reset_dist = 3.0 self._max_push_effort = 400.0 # values used for defining RL buffers self._num_observations = 4 self._num_actions = 1 self._device = \"cpu\" self.num_envs = 2 # a few class buffers to store RL-related states self.obs = torch.zeros((self.num_envs, self._num_observations)) self.resets = torch.zeros((self.num_envs, 1)) # set the action and observation space for RL self.action_space = spaces.Box(np.ones(self._num_actions) * -1.0, np.ones(self._num_actions) * 1.0) self.observation_space = spaces.Box(np.ones(self._num_observations) * -np.Inf, np.ones(self._num_observations) * np.Inf) # trigger __init__ of parent class BaseTask.__init__(self, name=name, offset=offset) and add another cartpole like this def set_up_scene(self, scene) -&gt; None: # retrieve file path for the Cartpole USD file # assets_root_path = get_assets_root_path() usd_path = \"/home/nscl2004/Study/rl/stb/skrl/examples/usd/cartpole.usd\" assets_root_path = get_assets_root_path() usd_path = assets_root_path + \"/Isaac/Robots/Cartpole/cartpole.usd\" # add the Cartpole USD to our stage create_prim(prim_path=\"/World/Cartpole\", prim_type=\"Xform\", position=self._cartpole_position) create_prim(prim_path=\"/World/Cartpole2\", prim_type=\"Xform\", position=self._cartpole_position2) add_reference_to_stage(usd_path, \"/World/Cartpole\") add_reference_to_stage(usd_path, \"/World/Cartpole2\") # create an ArticulationView wrapper for our cartpole - this can be extended towards accessing multiple cartpoles self._cartpoles = ArticulationView(prim_paths_expr=\"/World/Cartpole*\", name=\"cartpole_view\") # add Cartpole ArticulationView and ground plane to the Scene scene.add(self._cartpoles) scene.add_default_ground_plane() self.sd_helper = None self.viewport_window = None self._set_camera() # set default camera viewport position and target # self.set_initial_camera_params() and execute train code from skrl tutorial but I met this error. Traceback (most recent call last): File \"cartpole_example_skrl.py\", line 113, in &lt;module&gt; trainer.train() File \"/home/user/.local/share/ov/pkg/isaac_sim-2022.1.0/kit/python/lib/python3.7/site-packages/skrl/trainers/torch/sequential.py\", line 54, in train self.single_agent_train() File \"/home/user/.local/share/ov/pkg/isaac_sim-2022.1.0/kit/python/lib/python3.7/site-packages/skrl/trainers/torch/base.py\", line 208, in single_agent_train next_states, rewards, dones, infos = self.env.step(actions) File \"/home/user/.local/share/ov/pkg/isaac_sim-2022.1.0/kit/python/lib/python3.7/site-packages/skrl/envs/torch/wrappers.py\", line 322, in step observation, reward, done, info = self._env.step(self._tensor_to_action(actions)) File \"/home/user/.local/share/ov/pkg/isaac_sim-2022.1.0/kit/python/lib/python3.7/site-packages/skrl/envs/torch/wrappers.py\", line 309, in _tensor_to_action return np.array(actions.cpu().numpy(), dtype=space.dtype).reshape(space.shape) ValueError: cannot reshape array of size 2 into shape (1,) /home/user/.local/share/ov/pkg/isaac_sim-2022.1.0/python.sh: line 46: 60952 Segmentation fault (core dumped) $python_exe \"$@\" $args There was an error running python It's really hard to understand this error because I think if I set num_envs value as 2, trainer is automatically matching observation shape. Did anyone solve an error similar to this one?",
        "answers": [
            [
                "The problem comes from the definition of action space. self.action_space = spaces.Box(np.ones(self._num_actions) * -1.0, np.ones(self._num_actions) * 1.0) The size of the action space is only for one env and you should probably vectorize it or not use action space."
            ]
        ],
        "votes": [
            1e-07
        ]
    },
    {
        "question": "https://docs.nvidia.com/isaac/isaac/doc/doc/component_api.html#isaac-map-map states: This component is used to mark a node as a map and gives convenient access to the various map layers and also some cross-layer functionality. But it is not documented anywhere how to do that. In my case, I just want to know the defined waypoints in the WaypointMapLayer. How do I do this specifically and in general? The documentation seems to be really missing a lot of such details or examples still.",
        "answers": [
            [
                "After a long search, mostly through existing header files in the SDK, I found my way up through Codelet, Component::Node, to Application. The Application class has methods for finding arbitrary nodes in the application graph, specifically one can use: getNodeByName(const std::string&amp; name) const; In my case, I was able to call this in my components start method: // get the map node: isaac::alice::Node* map = node()-&gt;app()-&gt;getNodeByName(\"map\"); // within that node, get the WaypointMapLayer component: isaac::map::WaypointMapLayer* comp = map-&gt;getComponent&lt;isaac::map::WaypointMapLayer&gt;(); // get the configuration parameter we want: waypoints = comp-&gt;get_waypoints();"
            ]
        ],
        "votes": [
            1e-07
        ]
    }
]